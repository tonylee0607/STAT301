---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.0
  kernelspec:
    display_name: R
    language: R
    name: ir
---

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "43ec1a8cb72470b2a1670b31c8848a0c", "grade": false, "grade_id": "cell-f1e1d845873036f4", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# Worksheet 3: Introduction to Generative Modelling
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "0759b285d3e9aab838a8b34ac037782c", "grade": false, "grade_id": "cell-82d9926086d47a80", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## Learning Objectives

After completing this week's lecture and tutorial work, you will be able to:

1. Give an example of a question that could be answered by generative modelling.
2. Explain how a linear regression can be used to approximate the underlying mechanism that generated the data (quantitative response and input variables).
3. Interpret the estimated coefficients and $p$-values derived from theoretical results for a simple linear regression (i.e., one input variable).
4. Discuss the assumptions made to estimate the simple linear regression coefficients and approximate their sampling distribution.
5. Explain how to approximate the sampling distribution of the simple linear regression coefficient estimators using bootstrapping. 
6. Contrast the sampling distribution approximated using theoretical results with bootstrapping alternatives for a simple linear regression setting.
7. Compute confidence intervals for the simple linear regression coefficients using theoretical approximations and bootstrapping results.
8. Write a computer script to perform simple linear regression analysis.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'bdbf5c801ce3936aaded443060f02f0e', 'grade': False, 'grade_id': 'cell-a2a153352bc44a68', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# Run this cell before continuing.
library(tidyverse)
library(repr)
library(infer)
library(cowplot)
library(broom)
source("tests_worksheet_03.R")
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "6102d14aabf5d5aa6f5f512a0bd29efd", "grade": false, "grade_id": "cell-7a45b51c13b6ebc9", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# Generative models

As data scientists, we are often interested in understanding the relationship between variables in our data using *models*. For example:

- which variables are associated with a response of interest? 

- can we model the relationship between the response and the input variables? Is a linear model adequate?

- which variables are positively/negatively associated with the response? 

- does the relationship between the response and an input variable depend on the values of the other variables?

**Linear Regression Models can be used to answer these questions, providing a unifying framework to study the relation between different type of variables and a continuous response**
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "7bf0ae6d4c4e4f143053e1abe3ac0e1a", "grade": false, "grade_id": "cell-be373688c2e20c12", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Research in linear models has been focused on 3 important aspects: **estimation, inference, and prediction** 

- **Estimation**: how to estimate the true (but unknown) relation between the response and the input variables

- **Inference**: how to use the model to infer information about the unknown relation between variables

- **Prediction**: how to use the model to predict the value of the response for new observations 

**Note**: These goals are related!
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "ff8dfc776dab1bf33c79ee8169664630", "grade": false, "grade_id": "cell-1613c0cdb742774f", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# Introduction to Simple Linear Regression (SLR)

The purpose of this worksheet is to practice building, interpreting and testing SLR models. You will also become familiar with `R` functions such as `lm()` and `broom()` to accomplish these tasks. 

> "Simple" refers to a linear model with only *one* input variable!
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "7bb93ca340fcffdee246d9460740f761", "grade": false, "grade_id": "cell-09b1d3cf9ae20175", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## Case study

### Cancer Mortality

In this worksheet you will use the dataset `US_cancer_data` that contains data on cancer mortality rate and different demographic and medical variables in American counties. 

#### The question
You will examine the relationship between cancer mortality rates and different demographic and medical variables.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "6c72d2835d1cff771f8578751e3f4014", "grade": false, "grade_id": "cell-7bb952074a659258", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### Read in data

The data come from [data.world](https://data.world/nrippner/ols-regression-challenge) and other sources: [census.gov](http://census.gov/), [clinicaltrials.gov](http://clinicaltrials.gov/), and [cancer.gov](http://cancer.gov/). All values have been collected in the 2010s but vary per source.

> **Heads up**: Recall the importance of using a *random* sample to obtain representative summaries and broad conclusions!

In the [source documentation](https://data.world/nrippner/ols-regression-challenge) you can find the definition of each of the selected variables:

- `TARGET_deathRate`: a continuous variable that measures cancer mortality per capita (for every 100,000 inhabitants), obtained as an average of data collected from the years 2010-2016.

- `povertyPercent`: a continuous variable that measures percentage of the county's populace in poverty from 2013 American Census estimates.

- `PctPrivateCoverage`: a continuous variable that measures percentage of the county residents with private health coverage from 2013 American Census estimates. 

Let's start by reading this dataset!
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'eafb71e4257bf591db15e3938b5a09da', 'grade': False, 'grade_id': 'cell-3e3dd54caa25ebd4', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
US_cancer_data <- read_csv("data/US_county_cancer_data.csv") %>%
  select(TARGET_deathRate, povertyPercent, PctPrivateCoverage)
head(US_cancer_data)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "8bd378ab40b47f36e991753621a37950", "grade": false, "grade_id": "cell-3443ed42bc9381f7", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# PART I: Estimation
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "5faac52325539512a2c772fee97a276f", "grade": false, "grade_id": "cell-09645dfe5eb37823", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 1 The Model

You can hypothesize that the cancer mortality of each county is related to the average level of poverty. In this worksheet, you will quantitatively study the association, at county level, between `TARGET_deathRate` and `povertyPercent` using a SLR.

Note that this model is not exact or true. You are *assuming* that the cancer mortality rate changes *at a constant rate* with the percentage of populace poverty? Is this a reasonable assumption?
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "b95eedcf9f0224d50df830e7925ff8bb", "grade": false, "grade_id": "cell-53d9eed9dc88d641", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.0**
<br>{points: 1}


Within the context of this case study, answer the following:

**1.0.0.** Which variable will you choose as a response variable? Answer with the column's name from `US_cancer_data`.

**1.0.1.** Which variable will you choose an input variable? Answer with the column's name from `US_cancer_data`.


*Assign your answers to the objects `answer1.0.0` (character type surrounded by quotes), `answer1.0.1` (character type surrounded by quotes).*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '0d81c71b12162daa471cb7cf70301f4f', 'grade': False, 'grade_id': 'cell-5df91bad44bb6ee6', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer1.0.0 <- ...
# answer1.0.0
# answer1.0.1 <- ...
# answer1.0.1

# your code here
answer1.0.0 <- "TARGET_deathRate"
answer1.0.0
answer1.0.1 <- "povertyPercent"
answer1.0.1
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd099695f89e7cf95b93c48282c167a7a', 'grade': True, 'grade_id': 'cell-44112c42fed63850', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "48e0385fad55c1594b596e75d33ca78f", "grade": false, "grade_id": "cell-f5afa719df22abe6", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.1**
<br>{points: 1}

Using `US_cancer_data`, create a scatterplot of the response variable (in the y-axis) versus the input variable (in the x-axis). Call the resulting object `cancer_poverty_scatterplot`. 

> **Heads-up:** It is always important to display units of variables in plots to allow their proper interpretation!

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4ecfddda5fedc176d371a05e7cf615bc', 'grade': False, 'grade_id': 'cell-0c778621438a3597', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
options(repr.plot.width = 10, repr.plot.height = 7) # Adjust these numbers so the plot looks good in your desktop.


# cancer_poverty_scatterplot <- ggplot(..., aes(..., ...)) +
#   ...() +
#   xlab(...) +
#   ylab(...) +
#   theme(
#     text = element_text(size = 16.5),
#     plot.title = element_text(face = "bold"),
#     axis.title = element_text(face = "bold")
#   )
# cancer_poverty_scatterplot

# your code here
cancer_poverty_scatterplot <- ggplot(US_cancer_data, aes(povertyPercent, TARGET_deathRate)) +
  geom_point() +
  xlab("Poverty Percent") +
  ylab("Death Rate") +
  theme(
    text = element_text(size = 16.5),
    plot.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold")
  )
cancer_poverty_scatterplot


```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '59dd1e81a122412c6ba1b3798c47daca', 'grade': True, 'grade_id': 'cell-9ab30539bf2fa701', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "00bd93e106d98c19a07f3f60c8760f66", "grade": false, "grade_id": "cell-7067872e63649111", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.2**
<br>{points: 1}

Based on the `cancer_poverty_scatterplot`, how would you describe the graphical association between the response and the input variables?

**A.** Negative.

**B.** Positive.

*Assign your answer to an object called `answer1.2`. Your answer should be one of `"A"` or `"B"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'be4bc439c3f93ba197765ea1ffdec82a', 'grade': False, 'grade_id': 'cell-429bf5b7ffbb89e3', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer1.2 <- ...

# your code here
answer1.2 <- "B"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '7454a137074dc31c13726ec510817fc9', 'grade': True, 'grade_id': 'cell-191c4f6b4b8c3368', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "67d95312bc5b52f4451f1018fcc2ba3b", "grade": false, "grade_id": "cell-8b6239aadc3aeeb8", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 2. Estimation of the regression line

Let's start by formally defining the linear model. Then you will use data and code to **estimate** it!
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "41d62b92973521db89f3f5a7dad9ba06", "grade": false, "grade_id": "cell-93e9a51d61ab3cd2", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Let ${(X_i,Y_i): i = 1, \ldots , n}$ be a <font color="red">random sample</font> of size $n$ from the population

In this example:

- $Y_i$: the cancer mortality per capita for the $i$th county

- $X_i$: percentage of the populace in poverty for the $i$th county

> Note that the response and input are indexed by $i$ which could take on the following values: $1 , \dots, n$ to identify the $i$th county in the data.

Observations from a random sample won't be perfectly lined. The error term contains all factors that deviate $Y_i$ from its conditional expected value.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "e159bdc25f75fe0634b95585fd36a7cc", "grade": false, "grade_id": "cell-281afae81a6a20c5", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### The best line 
The population parameters are *unknown* and *non-random*. We *use data* from a random sample to *estimate* them!! But how ...???

There are infinite lines to choose from ... Which one is the best line??
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4d726ac95ebb7e50de24a0b38085c404', 'grade': False, 'grade_id': 'cell-268c65ead72e509c', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
US_cancer_data %>% ggplot(aes(povertyPercent, TARGET_deathRate)) + theme(axis.text.x = element_text(angle = 90))+
    geom_point()+ 
    geom_abline(intercept=145,slope=1.5, size=2, col = "blue")+
    geom_abline(intercept=200,slope=-1, size=2, col = "orange")+
    geom_abline(intercept=100,slope=5, size=2, col = "red")+
    geom_abline(intercept=155,slope=1.2, size=2, col = "green")+
    geom_abline(intercept=147,slope=1.9, size=2, col = "purple")+
    xlab("Populace in Poverty (%)") +
    ylab("Cancer Mortality per Capita (cases/100,000)")
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "f75f1361f0809aa4a0ee7d46061e1081", "grade": false, "grade_id": "cell-2b158505c3861cdb", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.0**
<br>{points: 1}

How would you choose the **best line**? 

**A.** The line that contains most data points 

**B.** The line that minimizes the distance of the points to the line 

**C.** The line that looks the best upon visual inspection

*Assign your answer to an object called `answer2.0`. Your answer should be one of `"A"`, `"B"`, or `"C"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '7c01a5b325328e23c7e13150a295e4ad', 'grade': False, 'grade_id': 'cell-b459136dda679dcc', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer2.0 <- ...

# your code here
answer2.0 <- "B"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '46bfea70534d580f63fa47671fe8350f', 'grade': True, 'grade_id': 'cell-cd9fd974ce85c373', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_2.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "e87fc328e1968d08279825e92961291c", "grade": false, "grade_id": "cell-c4485d13b5cbfabd", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.1**
<br>{points: 1}

To define the **best line** we need to know how to measure the distance of the points to the line! Which of the following criteria would you choose to define "distance of a point to the line"?? 

> **Note**: there is not a unique answer to this questions but only one corresponds to the least squares criterion

![](img/dist.png)

Figure by Prof. Joel Ostblom

*Assign your answer to an object called `answer2.1`. Your answer should be one of `"A"`, `"B"`, or `"C"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'b49e286c5cd5b0f9662b62f39f56c335', 'grade': False, 'grade_id': 'cell-0a1ade7f65d6d7ba', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer2.1 <- ...

# your code here
answer2.1 <- "B"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '8a1ee332fb09c598699b04610bd66f1a', 'grade': True, 'grade_id': 'cell-4383e4539b493894', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_2.1()
```

<!-- #region deletable=false editable=false jp-MarkdownHeadingCollapsed=true nbgrader={"cell_type": "markdown", "checksum": "c8a6c2d503c4e85e9d8d4e5efbe8964d", "grade": false, "grade_id": "cell-1dfa03dc1c34b14c", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Many methods can be used to estimate the true regression line depending on the criteria used to define "optimal"!

**Least Squares (LS) method** minimizes the sum of the *squares of the residuals*!!

#### Check [this application](http://setosa.io/ev/ordinary-least-squares-regression/)

#### Residual 

The residual of an observation is the difference between its response value and its predicted response on the line (dotted vertical line in **B**)

> **Note**: discuss why the **residual** is different from the **error term**. 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c97efba96f73f5612a22774a1be2b327", "grade": false, "grade_id": "cell-f86b3d1e24441d05", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 3. LS in R

We will use the `lm` function in R to obtain the LS estimates using the data in `US_cancer_data`.

> **Heads up**: LS is not the only method to estimate the regression coefficients. However, it is the default method in `lm`

The relevant arguments are:

- `formula`: takes the form `response ~ input`.
- `data`: takes a data frame in tidy format.

> **Note**: `lm(response ~ .,data= df)` uses all variables in the dataset `df`, except the `response`, as predictors 

> **Note**: `lm(response ~ input - 1,data= df)` forces the estimated intercept to be 0. Never do this unless you know what you are doing and why. 

In this dataset we have sample of size in $n = 3047$ to estimate the regression coefficients. To examine the properties of the estimator let's start with a smaller sample and see what happens as the sample size increases.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "66433b00d2f0e53d2df9199d82ec179b", "grade": false, "grade_id": "cell-6343bf91f6dd54a9", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.0**
<br>{points: 1}

From the pool of American counties `US_cancer_data`, use the function `rep_sample_n()` to collect one random sample of size `250` and call it `US_cancer_sample250`.

> Note: in principle the function `sample_n()` can also be used but gives a different output object so the autograding test fails.

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'da41b0b54b12c93c80d28101a22d755c', 'grade': False, 'grade_id': 'cell-ecd77df8d80a2f0c', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(123) # DO NOT CHANGE!

# US_cancer_sample250 <- ...(..., size = ...)

# your code here
US_cancer_sample250 <- rep_sample_n(US_cancer_data, size = 250)

head(US_cancer_sample250)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '1dfbe813f08a689765737bd3c17f5f2e', 'grade': True, 'grade_id': 'cell-d2d2ec2ce9fbba53', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_3.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "7ff71155bb12ed7d6cbcd9c5bf7c63a7", "grade": false, "grade_id": "cell-1e2f57ba013fa9eb", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.1**
<br>{points: 1}

It is time to use `R` for estimating the SLR using `US_cancer_sample250`. This estimated model can be used to evaluate if there exist a linear association between cancer mortality and poverty.

Use the `lm()` function to estimate the SLR. 

Store this estimated model in the variable `SLR_cancer_sample250`.

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '54cad00e26c4cffddf8d04215a26e2ce', 'grade': False, 'grade_id': 'cell-ea84f46f9ddc7886', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# SLR_cancer_sample250 <- ...(formula = , data = ...)
# SLR_cancer_sample250

# your code here
SLR_cancer_sample250 <- lm(formula = TARGET_deathRate ~ povertyPercent , data = US_cancer_sample250)
SLR_cancer_sample250
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'c7c679db630331d6ad1b7a1953992d00', 'grade': True, 'grade_id': 'cell-b1563dd87c648835', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_3.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "f478b492e1a6fd37772382ac2f3eac7b", "grade": false, "grade_id": "cell-cc795e1b37ab4190", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.2: Interpretation of the estimated line**
<br>{points: 1}

What is the correct interpretation of the regression estimated slope in `SLR_cancer_sample250_results`?

**A.** The effect of a one percent increase of the county's populace in poverty is 1.52 increase in the cancer mortality per capita (cases/100,000).

**B.** One percent increase of the county's populace in poverty causes 1.52 increase in cancer mortality per capita (cases/100,000).

**C.** The expected cancer mortality per capita (cases/100,000) increases by 1.52 per one percent increase of the county's populace in poverty.

*Assign your answer to an object called `answer3.2`. Your answer should be one of `"A"`, `"B"`, or `"C"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '90ee2a04952b7d13b7f96b2aac68138b', 'grade': False, 'grade_id': 'cell-230aae9574584b5d', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer3.2 <- ...

# your code here
answer3.2 <- "C"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '1a61917d3308d35ccd65f34508ea4041', 'grade': True, 'grade_id': 'cell-1d526f4a65786abe', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_3.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "31b5298256f5678bbc455c9ddf2af67e", "grade": false, "grade_id": "cell-11a76c9e8ed8deca", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.3: Visualization of the estimated line**
<br>{points: 1}

Using `US_cancer_sample250`, we can plot `TARGET_death_rate` versus `povertyPercent` **with points** and add the estimated SLR. The `ggplot()` object's name will be `SLR_cancer_sample250_plot`

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '97382d92b0883be8205f2963f38b5408', 'grade': False, 'grade_id': 'cell-004d6fa208dffe3c', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# SLR_cancer_sample250_plot <- ggplot(..., aes(..., ...)) +
#   ...() +
#   ...(aes(..., ...), ..., se = FALSE, size = 1.5) +
#   coord_cartesian(xlim = c(0, 50), ylim = c(50, 400)) +
#   xlab(...) +
#   ylab(...) +
#   ggtitle("Sample Scatterplot and Estimated SLR") +
#   theme(
#     text = element_text(size = 16.5),
#     plot.title = element_text(face = "bold"),
#     axis.title = element_text(face = "bold")
#   )


# your code here
SLR_cancer_sample250_plot <- ggplot(US_cancer_sample250, aes(povertyPercent, TARGET_deathRate)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, size = 1.5) +
  coord_cartesian(xlim = c(0, 50), ylim = c(50, 400)) +
  xlab("Poverty Percent") +
  ylab("Death Rate") +
  ggtitle("Sample Scatterplot and Estimated SLR") +
  theme(
    text = element_text(size = 16.5),
    plot.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold")
  )

SLR_cancer_sample250_plot


```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '6ba6bed05ae51ca92cacf6486a494e65', 'grade': True, 'grade_id': 'cell-623838e992d12dcf', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_3.3()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "5dc64c29f1bda401bed782441c3a3bde", "grade": false, "grade_id": "cell-90c1efbcff5d2739", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.4**
<br>{points: 1}

Considering the SLR model estimated in this exercise, which of the following questions relates to inference and estimation, and which relates to prediction? 

| **Question** | **Type** |
| ------------------------------- | ----------------------- |
| How can we determine an association between the expected cancer mortality per capita (cases/100,000) and the countyâ€™s populace living in poverty of all American counties? | `answer3.4.0` |
| We observe a new American county with 14% of its populace living in poverty. What cancer mortality per capita (cases/100,000) should we expect? | `answer3.4.1` |

The right column of the table is empty but should describe one of the following: 

**A.** Prediction.

**B.** Inference and estimation.

*Assign your answers to the objects `answer3.4.0` and `answer3.4.1`. Your answer should each be a single character (`"A"` or `"B"`) surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'ffb380dd27c18eecb0913977c01c1689', 'grade': False, 'grade_id': 'cell-48589f0e8415d279', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer3.4.0 <- ...
# answer3.4.1 <- ...

# your code here
answer3.4.0 <- "B"
answer3.4.1 <- "A"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '745eee2014caf24b111deee5ca2cc1fe', 'grade': True, 'grade_id': 'cell-c2bcf367549a3797', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_3.4()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "5897dc98730e18a75a3e8f895f0e0ad4", "grade": false, "grade_id": "cell-e24077061b7962f7", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# PART II: Inference
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "0f7e40ffee8d8fc48304819126950a23", "grade": false, "grade_id": "cell-298b195aadb7b3e9", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Since the parameters of the linear model ($\beta_0$ and $\beta_1$) are unknow you use a random sample to estimate with a LS estimator ($\hat{\beta}_0$ and $\hat{\beta}_1$). 

In particular, in this case study, the estimated intercept and slope in `SLR_cancer_sample250_results` are computed using the $n = 250$ sampled observations from `US_cancer_data`. 

> We can think that the *estimates* are (good) guesses about the population parameters based on our data. 

In this section we will examine how we can infer information about the *population* parameters from the *estimated* parameters. 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "71a3f3551d5031741edb2f7aaf8d13eb", "grade": false, "grade_id": "cell-c73ed4b937081d6a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## Randomness

Since $\hat{\beta}_0$ and $\hat{\beta}_1$ are computed from a random sample, they are random variables themselves! The values of the estimates *depend* on the random sample used to compute them:

> **Important**: different samples yield different estimates!!

Let's see an example! Recall the estimates we obtained with the sample taken:
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4e725c8a1c4dd13f504a9825eb0bb49d', 'grade': False, 'grade_id': 'cell-103fb55d72933468', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
SLR_sample250_0 <- tidy(lm(formula = TARGET_deathRate ~ povertyPercent, data = US_cancer_sample250)) %>% select(estimate)
many_SLR <- SLR_sample250_0 
many_SLR
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "72765eff77f474339fca6782ac992be2", "grade": false, "grade_id": "cell-6535c30895a53ccd", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Take *another sample* from the full dataset and estimate the regression line

> **Important**: In practice, we will rarely take multiple samples!

> **NOTE**: This is NOT bootstrapping!! Why??
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '184ad931446ed988892ed1b83ed10902', 'grade': False, 'grade_id': 'cell-4485e6151bc62eb9', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
set.seed(301)

US_cancer_sample250_1 <- rep_sample_n(US_cancer_data, size = 250)

```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'a8eee35d70b21540268a1ff78df9b005', 'grade': False, 'grade_id': 'cell-3a8d370d09a8e5ad', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# ANOTHER POINT ESTIMATES

SLR_sample250_1 <- tidy(lm(formula = TARGET_deathRate ~ povertyPercent, data = US_cancer_sample250_1))  %>% select(estimate)
many_SLR <- many_SLR %>% bind_cols(SLR_sample250_1)
many_SLR
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'be141f5618073a587a7d6de82bbe73fd', 'grade': False, 'grade_id': 'cell-bb611db621ae47fd', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
set.seed(30)

US_cancer_sample250_2 <- rep_sample_n(US_cancer_data, size = 250)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '2e64cc91e0e9edcbf154a09c3d11a7eb', 'grade': False, 'grade_id': 'cell-bff2112896f5ac31', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# ANOTHER POINT ESTIMATES

SLR_sample250_2 <- tidy(lm(formula = TARGET_deathRate ~ povertyPercent, data = US_cancer_sample250_2))  %>% select(estimate)
many_SLR <- many_SLR  %>% bind_cols(SLR_sample250_2)
many_SLR
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "30aecbb913d3cd233acabaf89d6a50e2", "grade": false, "grade_id": "cell-2e1e8a7cab7c4b20", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### and so on .... as we take new samples we get different *estimates* of the regression parameters

> **Important**: what is the sample-to-sample variation??

## 4. The standard error!!

The variation of these estimates from sample to sample is measured by their standard deviation, which has a special name: *the standard error* (SE)

> But in practice, how can we compute the standard error if we have only 1 sample?? 

We have different ways of answering this question:

1. take multiple samples from the population and compute multiple estimates as we did above. Then compute their SD. But this is *not a realistic option*  

2. use a theoretical result! This is what `lm` does!!

3. use bootstrapping!! As you did in STAT 201 for other quantities!! This is what we will also do in STAT 301
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "e09eb6db50f780ef92be579014b32e2b", "grade": false, "grade_id": "cell-7b727dcdc90f2a93", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 4.0**
<br>{points: 1}

Use the `broom` package's `tidy()` to obtain the estimated coefficients, associated standard errors, $t$-statistics, and $p$-values obtained from the random sample `SLR_cancer_sample250`. 

Store them in the variable `SLR_cancer_sample250_results` whose columns are the following:

- The first column has the names of the regression terms.

- The second column shows the values of the estimated coefficients of the regression line, $\hat{\beta}_0$ and $\hat{\beta}_1$ 

- The remaining three columns have important quantities to assess uncertainty and test hypotheses about the regression terms (we'll learn more about these quantities later).

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '608923e5a276f5fa1c1c5232d326589f', 'grade': False, 'grade_id': 'cell-52d5c9eef3b26e20', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# SLR_cancer_sample250_results <- ...(...) %>% mutate_if(is.numeric, round, 2)
# SLR_cancer_sample250_results

# your code here
SLR_cancer_sample250_results <- broom::tidy(SLR_cancer_sample250) %>% mutate_if(is.numeric, round, 2)
SLR_cancer_sample250_results
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd7dd796963e48c42d4407504af6dd56c', 'grade': True, 'grade_id': 'cell-635ad3148a1c83b4', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_4.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c44261ea73722dbb705be3c8723baf03", "grade": false, "grade_id": "cell-c8684be2efde0514", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 5. Hypothesis Tests

The object `SLR_cancer_sample250_results` contains useful information to test some hypotheses about the regression coefficients.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c853200f5ef51f61b1373c59110ebfb7", "grade": false, "grade_id": "cell-39c0e09371a6e400", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 5.1 The null hypothesis

As in other hypothesis tests, the null hypothesis claims a *null* state. In SLR, the *null* relation between the response and the input variable(s). 

> **Note**: the null hypothesis claims the contrary of what we want to prove. We will prove our point finding sufficient evidence in the data to reject $H_0$. 

**Question 5.1**
<br>{points: 1}

Suppose we want to test if the there exist a linear association between cancer mortality and poverty. Which of the following null hypotheses is correct:

**A.** $H_0: \hat{\beta}_1 = 0 $

**B.** $H_0: \hat{\beta}_0 = 0 $

**C.** $H_0: \beta_1 = 0$ 

**D.** $H_0: \beta_0 = 0$ 

*Assign your answer to an object called `answer5.1`. Your answer should be one of `"A"`, `"B"`, `"C"`, or `"D"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '109bb0f3ef423971a95c4cdd864e8bcf', 'grade': False, 'grade_id': 'cell-0e00abceb50441a9', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer5.1 <- 

# your code here
answer5.1 <- "C"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '9c2955bb1c3f23e20048a28dabc2afe2', 'grade': True, 'grade_id': 'cell-7ff71adbd8d78931', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_5.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "8dcf4edd865444c93c12e562264451f6", "grade": false, "grade_id": "cell-80d21f8215791485", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 5.2 The alternative hypothesis 

The alternative hypothesis reflects our believes about reality. 

> **Heads up**: Although the alternative hypothesis contains the claim that we want to prove, it is important to note that in statistics we are not proving that the null hypothesis is true or false! We can only *reject* or *fail to reject* the null hypothesis based on our evidence in the data!!

**Question 5.2**
<br>{points: 1}

Suppose we want to test if the there exist a positive (linear) association between the response and the input variable. Which of the following null hypotheses is correct:

**A.** $H_1: \hat{\beta}_1 > 0 $

**B.** $H_1: \hat{\beta}_0 > 0 $

**C.** $H_1: \beta_1 \neq 0$ 

**D.** $H_1: \beta_1 > 0$ 

*Assign your answer to an object called `answer5.2`. Your answer should be one of `"A"`, `"B"`, `"C"`, or `"D"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '0c5d49a184867b37f7c698e1af500203', 'grade': False, 'grade_id': 'cell-a52907f64399935c', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer5.2 <- 

# your code here
answer5.2 <- "D"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '8fc58f7443e24814f1c74291acf89c7e', 'grade': True, 'grade_id': 'cell-354611ba3fc83f6f', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_5.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "293c2c42e11d537261c1fcc09cf54711", "grade": false, "grade_id": "cell-391c3bab7c1d8f34", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 5.3 The statistic and $p$-value

To test $H_0$ we can use our estimated slope and check how far the estimate $\hat{\beta}_1$ is from $0$. The test statistic is a relative measure that we can use base on our data. It can be found in the column `statistic` from `SLR_cancer_sample250_results`

Using classical results of the sampling distribution of the LS estimators, `lm` computes $p$-values for the test. In `SLR_cancer_sample250_results`, you can find the $p$-values in the column `p.value`. 

> **Heads up**: By default, the alternative hypothesis is $H_1: \beta_j \neq 0$, for all $j$th coefficients. But you can change the default settings!!

The `p.value` is interpreted as the probability, under $H_0$, that $\mid T \mid$ is equal or larger than the value observed in our sample (given in the column `statistic` of `SLR_cancer_sample250_results`). 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "1d487ccdb2ac3259684a67579d39cad0", "grade": false, "grade_id": "cell-aceb18fffce6f3bd", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 5.3**

Which of the following statement is correct??

**A.** The p-value is not the probability that the null hypothesis is true

**B.** The p-value is the probability that the alternative hypothesis is false

**C.** The p-value indicates the size or importance of the observed effect

**D.** The p-value is the probability that the observed effects were produced by random chance alone.

*Assign your answer to an object called `answer5.3`. Your answer should be one of `"A"`, `"B"`, `"C"`, or `"D"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '5fa8e6a3b98463b88f31693185ebf723', 'grade': False, 'grade_id': 'cell-8f6efb5c992214ae', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer5.3 <- 

# your code here
answer5.3 <- "A"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '00b10a9dcf422c8a5fa7d437bf078029', 'grade': True, 'grade_id': 'cell-2cbff06858dd9fe1', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_5.3()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "d5f18cf523a15b9a45aac57911795434", "grade": false, "grade_id": "cell-2427447083645e6e", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 5.4 Decision rule

The smaller the $p$-value, the stronger the evidence against $H_0$. Thus, small $p$-values (less than the significance level $\alpha$) indicate that the data provides enough statistical evidence against the null hypothesis of no association (i.e., to reject $H_0$).

> **Heads up**: in the last years, the scientific community has identified the "crisis of p-values". If you are interested in this topic you can read more about it in [this article](https://www.nature.com/articles/d41586-019-00857-9) and in the [ASA statement](https://www.stat.berkeley.edu/~aldous/Real_World/ASA_statement.pdf).
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "33c6e995c65057a9c014eb40c095176a", "grade": false, "grade_id": "cell-3c6059e23bc9f677", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 5.4**
<br>{points: 1}

Using the output stored in `SLR_cancer_sample250_results` and a significance level $\alpha = 0.05$, in plain words, what is the conclusion of the following hypothesis test?

$H_0: \beta_1 = 0 $

$H_1: \beta_1 \neq 0 $

**A.** We accept the alternative hypothesis; thus, the percentage of the county's populace in poverty has a statistically significant effect on the county's cancer mortality per capita (cases/100,000).

**B.** We reject the null hypothesis; thus, the percentage of the county's populace in poverty is statistically associated with the county's cancer mortality per capita (cases/100,000).

**C.** We fail to reject the null hypothesis; thus, the percentage of the county's populace in poverty is not statistically associated with the county's cancer mortality per capita (cases/100,000).

*Assign your answer to an object called `answer5.4`. Your answer should be one of `"A"`, `"B"`, or `"C"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '7a3e3ce3002777d2e77185fce447146d', 'grade': False, 'grade_id': 'cell-82d0f59970d0e80b', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer5.4 <- 

# your code here
answer5.4 <- "B"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '15a53f5140ec0c579bf954258317e635', 'grade': True, 'grade_id': 'cell-f9f55247b699d582', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_5.4()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "9a162cf79db02ab0f1a77441c2a68220", "grade": false, "grade_id": "cell-686562cd18489a63", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 6. Confidence Intervals

The values in `SLR_cancer_sample250_results` can also be used to compute confidence intervals for the regression parameters! 

**Note**: A 95% CI computed from the data is **not** a range of values that contain the true regression parameter with 95% probability. Once the interval has been computed based on the data, *nothing is random*! so it either covers or not the true value. 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "05f9b5ca7e9f8400eb93873ecc74fbb6", "grade": false, "grade_id": "cell-f2039776b449200a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 6.0**
<br>{points: 1}

Using `SLR_cancer_sample250` via `tidy()`, obtain the asymptotic 95% CIs for each regression parameters.

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd19550d1854fe3a7633ba89628959d76', 'grade': False, 'grade_id': 'cell-0468635376dc8c51', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# SLR_cancer_sample250_CIs <- ...(..., ...) %>% mutate_if(is.numeric, round, 2)
# SLR_cancer_sample250_CIs

# your code here
SLR_cancer_sample250_CIs <- tidy(SLR_cancer_sample250, conf.int = TRUE) %>% mutate_if(is.numeric, round, 2)
SLR_cancer_sample250_CIs
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4d689653c19ec74cf2f9ce35f4b492a2', 'grade': True, 'grade_id': 'cell-5fb8e28b96479507', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_6.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "01a870faa6bb22c2e5d52399792b6e02", "grade": false, "grade_id": "cell-757d9c75042a3693", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 7. The Sampling Distribution

We mentioned before that the estimators of the regression coefficient, $\hat{\beta}_0$ and $\hat{\beta}_1$, are *random variables*. Then they also have a *distribution*, called the *sampling distribution* (same as in STAT 201!). And we need this distribution to compute $p$-values!!

But how do we know the *sampling distribution* (i.e., the distribution of the estimators of the regression coefficients)??

We have different ways of answering this question:

1. take multiple samples from the population and compute multiple estimates as we did above. Then look at their distribution. But this is *not a realistic option* 

2. use a theoretical result! This is what `lm` does!!

3. use bootstrapping!! As you did in STAT 201 for other quantities!! This is what we will also do in STAT 301
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "0eef14e5e00b8ef013d97edc0446868d", "grade": false, "grade_id": "cell-445f38e1a47dfe51", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
In Statistics, bootstrapping refers to sampling from our original sample **with replacement** (also called **resampling with replacement**) to generate a **bootstrap sampling distribution**. 

>  **Heads up**: **sampling with replacement** means that each time we choose an observation from the sample, we return it before randomly selecting another. Resampling with replacement is required to get enough samples to approximate the sampling variation.

The idea is to use the original sample as an *estimate* of the unknown population. 

<font color="blue">Again, note that we are sampling from the sample!! not from the population!!</font>
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "d629a9c79dd0dba42917a12aa3c3a074", "grade": false, "grade_id": "cell-6f316bcec0b455d7", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Using *bootstraping*, we generate a *long* list of estimates to *empirically* approximate the sampling distribution!

- sample with replacement to obtain $B$ samples with size $n$

- for each sample, compute the estimated regression coefficients

- use the $B$ regression estimates of a given population parameter to calculate the sampling distribution of its estimator

> **Heads up**: this list can also be used to estimate the mean and the standard error of the estimator
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c62f8c79e13e6df7ec70cad1daac1894", "grade": false, "grade_id": "cell-3dd94e05c39bfb81", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 7.1 Bootstrap estimates

Let's generate a bootstrap list of estimates from `US_cancer_sample250`.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "58c7550316f8ad6a30023aaeb13a776f", "grade": false, "grade_id": "cell-d57a445477211915", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.1.0**
<br>{points: 1}

Let's approximate the bootstrapping sampling distribution using `US_cancer_sample250`. 

Obtain $B = 1000$ sets of regression estimates by fitting a SLR $B$ times using their respective boostrap sample. Store the corresponding bootstrap estimates in the data frame `lm_boot250` of 1000 rows and two columns:

- `boot_intercept`: list of bootstrap intercepts
- `boot_slope`: list of bootstrap slopes 

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'f068218a4f15c9a691810e31a3ec9333', 'grade': False, 'grade_id': 'cell-6f2151f404bba317', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(123)  # DO NOT CHANGE!

# n <- ...
# B <- ...

# lm_boot250 <- replicate(..., {
#   sample_n(..., ..., ...) %>%
#     lm(..., data = .) %>%
#     .$coef
# })
# lm_boot250 <- data.frame(boot_intercept = lm_boot250[1, ], boot_slope = lm_boot250[2, ])

# head(lm_boot250)
# tail(lm_boot250)

# your code here
n <- nrow(US_cancer_sample250)
B <- 1000

lm_boot250 <- replicate(B, {
  sample_n(US_cancer_sample250, size = n, replace = TRUE) %>%
    lm(TARGET_deathRate ~ povertyPercent, data = .) %>%
    .$coef
})
lm_boot250 <- data.frame(boot_intercept = lm_boot250[1, ], boot_slope = lm_boot250[2, ])

head(lm_boot250)
tail(lm_boot250)


```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd51ec5c3513ad950d6a3d1709217f0bf', 'grade': True, 'grade_id': 'cell-13b76464c3364af8', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.1.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "79d1ee31f265623a254003b33853d9f6", "grade": false, "grade_id": "cell-02d8481cfbb57f95", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### Using `infer`

Note that you can also use the `infer` package to get a list of bootstrap estimates of the regression coefficients!! As an exaple, let's get the list of the slope of the SLR.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "572457d2529f169c1e8b570c613c2352", "grade": false, "grade_id": "cell-2d1e3e7a9b0f5a20", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.1.1**
<br>{points: 1}

Use the package `infer` to generate bootstrap samples from `US_cancer_sample250` and estimate the slope of the SLR for each bootstrap sample.

Obtain $B = 1000$ sets of regression estimates by fitting a SLR $B$ times using their respective boostrap sample. Store the corresponding estimates per boostrap sample in an object called `bootstrap_slope_infer`. 

The resulting object should have 1000 rows and two columns:

- `replicate`: a numeric ID to identify the bootstrap sample and estimate
- `stat`: the bootstrap slope estimated from the corresponding bootstrap sample

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '7ddd36759a1be314b7e96fa258beaad7', 'grade': False, 'grade_id': 'cell-509840208b086dee', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(123)  # DO NOT CHANGE!

# bootstrap_slope_infer <- ... %>% 
#   specify(formula = ... ~ ...) %>%
#   generate(reps = ..., type = "bootstrap") %>% 
#   calculate(stat = "slope")
# head(bootstrap_slope_infer)

# your code here
bootstrap_slope_infer <- US_cancer_sample250 %>% 
  specify(formula = TARGET_deathRate ~ povertyPercent) %>%
  generate(reps = B, type = "bootstrap") %>% 
  calculate(stat = "slope")
head(bootstrap_slope_infer)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "6e10acf4fbe35bf871f29b385ca418f4", "grade": false, "grade_id": "cell-eb44619c08f82263", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Note**: each method uses different functions to generate bootstrap samples so even if we use the same seeds you don't get the same samples and estimates.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '94049c78ca151f1c2fe06bc6c8d4a330', 'grade': True, 'grade_id': 'cell-2b71a7f905dd38a3', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.1.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "108955ef197a83613bf38099b392a0ba", "grade": false, "grade_id": "cell-7ba7a6a784df3e04", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 7.2 Bootstrap sampling distribution

Let's approximate the sampling distribution of the regression estimators in our problem using the list of bootstrap estimates generated from `US_cancer_sample250`
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "2d56780769cfbcaa79416589c1c8bb45", "grade": false, "grade_id": "cell-551d6111e2c02e14", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.2.0**
<br>{points: 1}

Now that we have a list of bootstrap estimates, we can compute the visualize sampling distribution!

Let's focus on the sampling distribution of the slope. Use the list of bootstrapped estimates of the slopes stored in `lm_boot250` to plot the sampling distribution of the least square estimator of the slope.

The `ggplot()` object's name will be `slope_sampling_dist_250`


*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '11e6a5af9e08816c4b14b8f5e032b99b', 'grade': False, 'grade_id': 'cell-7e48d70a5fd7e6ba', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
#slope_sampling_dist_250 <-  ggplot(..., aes(x = ...)) +
#    geom_histogram(bins = 30, color = "white", fill = "blue") +
#    coord_cartesian(xlim = c(0, 3)) +
#    xlab("...") +
#    ggtitle("Bootstrap sampling distribution for the estimator of the slope, n=250")

#slope_sampling_dist_250 


# your code here
slope_sampling_dist_250 <-  ggplot(lm_boot250, aes(x = boot_slope)) +
   geom_histogram(bins = 30, color = "white", fill = "blue") +
   coord_cartesian(xlim = c(0, 3)) +
   xlab("Slope") +
   ggtitle("Bootstrap sampling distribution for the estimator of the slope, n=250")

slope_sampling_dist_250 


```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '8c83ba36ef90d11a23def9e22b99ad00', 'grade': True, 'grade_id': 'cell-52143fa0beedf514', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.2.0()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "395715a9bac5c03606071976f10173f7", "grade": false, "grade_id": "cell-ce690379019a47b5", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### With `infer`

You can also use the package `infer` to visualize the distribution of the bootstrap estimates generated. Check how similar both plots are!!
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'bcb44886c73f2fe07f81672caf014f8b', 'grade': False, 'grade_id': 'cell-4c22b93a3fb803cc', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
#run this cell

visualize(bootstrap_slope_infer, bin=30)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "8710af7c3fa51c67672d641c4497d93a", "grade": false, "grade_id": "cell-50ed6b45bdefbbcc", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### Does the sample size matter?

Our estimator depends on a random sample and thus on its size! What happen to the estimates and the sampling distribution when we change the sample size? 

Let's approximate the sampling distribution of estimators computed from samples of different sizes 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "7b6390db5c11ef3ccab9de529a5b1738", "grade": false, "grade_id": "cell-4222768aa1dba6ad", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.2.1**
<br>{points: 2}

- start with a new sample of size $n=500$

- repeat the bootstrapping experiment above 

- plot the sampling distribution

The `ggplot()` object's name will be `slope_sampling_dist_500`

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'fb398aea806068bbbf7fc7628a2e97a7', 'grade': False, 'grade_id': 'cell-5e67e1eed426b7b9', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(123)  # DO NOT CHANGE!
US_cancer_sample500 <- rep_sample_n(US_cancer_data, size = 500)  # DO NOT CHANGE!

# n <- ...
# B <- ...

# lm_boot500 <- replicate(..., {
#   sample_n(..., ..., ...) %>%
#     lm(..., data = .) %>%
#     .$coef
# })
# lm_boot500 <- data.frame(boot_intercept = lm_boot500[1, ], boot_slope = lm_boot500[2, ])

#slope_sampling_dist_500 <-  ggplot(..., aes(x = ...)) +
#    geom_histogram(bins = ...,color = "white", fill = "blue") +
#    coord_cartesian(xlim = c(0, 3)) +
#    xlab("...") +
#    ggtitle("Sampling distribution for the estimator of the slope, n=500")

#slope_sampling_dist_500 



# your code here
n <- 500
B <- 1000

lm_boot500 <- replicate(B, {
  sample_n(US_cancer_sample500, size = n, replace = TRUE) %>%
    lm(TARGET_deathRate ~ povertyPercent, data = .) %>%
    .$coef
})
lm_boot500 <- data.frame(boot_intercept = lm_boot500[1, ], boot_slope = lm_boot500[2, ])

slope_sampling_dist_500 <-  ggplot(lm_boot500, aes(x = boot_slope)) +
   geom_histogram(bins = 30,color = "white", fill = "blue") +
   coord_cartesian(xlim = c(0, 3)) +
   xlab("Slope") +
   ggtitle("Sampling distribution for the estimator of the slope, n=500")

slope_sampling_dist_500 
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '402527823371026dd505a9512683e0e5', 'grade': True, 'grade_id': 'cell-8bf369dbf7a904aa', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.2.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "dc0923e82ff9d9775bb94dda72a907e8", "grade": false, "grade_id": "cell-181f6cd34bc0fc7c", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.2.2**
<br>{points: 1}

- use sample of $n=1500$ American counties!

- repeat the bootstrapping experiment above 

- plot the sampling distribution

The `ggplot()` object's name will be `slope_sampling_dist_1500`

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '13c391e2cb07972b9e4f9741843e2a49', 'grade': False, 'grade_id': 'cell-3277df29e2a26547', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(123)  # DO NOT CHANGE!

# n <- ...
# B <- ...

# lm_boot1500 <- replicate(..., {
#   sample_n(..., ..., ...) %>%
#     lm(..., data = .) %>%
#     .$coef
# })
# lm_boot1500 <- data.frame(boot_intercept = lm_boot1500[1, ], boot_slope = lm_boot1500[2, ])

#slope_sampling_dist_1500 <-  ggplot(..., aes(x = ...)) +
#    geom_histogram(bins = ..., color = "white", fill = "blue") +
#    coord_cartesian(xlim = c(0, 3)) +
#    xlab("...") +
#    ggtitle("Sampling distribution for the estimator of the slope, n=1500")

#slope_sampling_dist_1500



# your code here

n <- 1500
B <- 1000

lm_boot1500 <- replicate(B, {
  sample_n(US_cancer_data, size = n, replace = TRUE) %>%
    lm(TARGET_deathRate ~ povertyPercent, data = .) %>%
    .$coef
})
lm_boot1500 <- data.frame(boot_intercept = lm_boot1500[1, ], boot_slope = lm_boot1500[2, ])

slope_sampling_dist_1500 <-  ggplot(lm_boot1500, aes(x = boot_slope)) +
   geom_histogram(bins = 30, color = "white", fill = "blue") +
   coord_cartesian(xlim = c(0, 3)) +
   xlab("Slope") +
   ggtitle("Sampling distribution for the estimator of the slope, n=1500")

slope_sampling_dist_1500
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'be3371ea19fdaf6f530d4fe20265ac35', 'grade': True, 'grade_id': 'cell-9eacf9d8f5f16848', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.2.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "fe270f76eeed88c50e728900935f1695", "grade": false, "grade_id": "cell-b6e751621f62bdc3", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Looking at the 3 sampling distributions obtained by bootstrapping from samples of different sizes, side-by-side
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '93cff202f81145166822f8165af213a2', 'grade': False, 'grade_id': 'cell-9db0f9c688ac0211', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
#run this cell

plot_grid(slope_sampling_dist_250 , slope_sampling_dist_500 ,slope_sampling_dist_1500 )
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "7729696f9a0cd6a29f17965aad98b9c5", "grade": false, "grade_id": "cell-d924b53e12f0f3e8", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.2.3**
<br>{points: 1}

Which of the following observataion about the sampling distribution is true?

**A.** The sampling distribution of the estimator of the slope does not change with the size of the sample we bootstrapped from

**B.** The center of sampling distribution of the estimator of the slope does not change with the size of the sample we bootstrapped from

**C.** The sampling distribution of the estimator of the slope becomes tighter as the size of the sample we bootstrapped from increases


*Assign your answer to an object called `answer7.2.3`. Your answer should be one of `"A"`, `"B"`, or `"C"` surrounded by quotes.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '322fbf8eaeab05d650e9c228b105f3c9', 'grade': False, 'grade_id': 'cell-663ee2b25173845e', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer7.2.3 <- 

# your code here
answer7.2.3 <- "C"
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'ea5cdab4cdecacf1450a52f181422022', 'grade': True, 'grade_id': 'cell-2f4bff560ebf9499', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.2.3()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "5bd7dbe410b344d2abde23099b0d081f", "grade": false, "grade_id": "cell-255147851923a584", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
### 7.3 Bootstrap Confidence Intervals

In this exercise we use the bootstrapping sampling distribution to compute *bootstrap percentile* CIs of regression parameters.

This empirical sampling distribution can be used to make inference, for example to construct CIs (also done in STAT 201). We will use the percentile method to obtain CIs from the list of bootstrap estimates.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "8cd8fc7efa61e341e4cb004cc5c2446a", "grade": false, "grade_id": "cell-9e63ef9fff646bef", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 7.3**
<br>{points: 1}

Obtain a summary of the $B$ results, `boot_SLR_cancer_CIs`, from `lm_boot250` with two rows (one for `boot_intercept` and another for `boot_slope`) and three columns: boostrap estimate average (`B_avg`), 95% lower bound quantile (`B_conf.low`), and 95% upper bound quantile (`B_conf.high`).

*Fill out those parts indicated with `...`, uncomment the corresponding code in the cell below, and run it.*
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '2a76c3b91af006ab16cfdc670cd2d640', 'grade': False, 'grade_id': 'cell-a482050162452f49', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# boot_SLR_CIs <- data.frame(
#   B_avg = lm_boot250 %>% summarize(
#     boot_intercept = ...,
#     boot_slope = ...
#   ) %>% unlist(),
#   B_conf.low = lm_boot250 %>% summarize(
#     boot_intercept = ...,
#     boot_slope = ...
#   ) %>% unlist(),
#   B_conf.high = lm_boot250 %>% summarize(
#     boot_intercept = ...,
#     boot_slope = ...
#   ) %>% unlist()
# ) %>% mutate_if(is.numeric, round, 2)
# boot_SLR_CIs

# your code here
boot_SLR_CIs <- data.frame(
  B_avg = lm_boot250 %>% summarize(
    boot_intercept = mean(boot_intercept),
    boot_slope = mean(boot_slope)
  ) %>% unlist(),
  B_conf.low = lm_boot250 %>% summarize(
    boot_intercept = quantile(boot_intercept, 0.025),
    boot_slope = quantile(boot_slope, 0.025)
  ) %>% unlist(),
  B_conf.high = lm_boot250 %>% summarize(
    boot_intercept = quantile(boot_intercept, 0.975),
    boot_slope = quantile(boot_slope, 0.975)
  ) %>% unlist()
) %>% mutate_if(is.numeric, round, 2)
boot_SLR_CIs
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '73d1c353bd941165f36abd9eeac785ab', 'grade': True, 'grade_id': 'cell-ef0c4b63ae9bcccb', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_7.3()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "885d87abe3370ec9aef95328446321ed", "grade": false, "grade_id": "cell-76a07ae1a0fce105", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### With `infer`
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'e69220da3b1a1cccff83dcde579dd92c', 'grade': False, 'grade_id': 'cell-aa2fd985f1e73da9', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
#run this cell

percentile_ci <- bootstrap_slope_infer %>% 
  get_confidence_interval(type = "percentile", level = 0.95)
percentile_ci
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'b609365b9700bfc20a907c576d5e0fa4', 'grade': False, 'grade_id': 'cell-83cc236a3c794c8c', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
slope_sampling_dist_250 <-  ggplot(lm_boot250, aes(x = boot_slope)) +
    geom_histogram(bins = 30, color = "white", fill = "blue") +
    geom_vline(aes(xintercept = quantile(boot_slope,0.025)),size=1)+
    geom_vline(aes(xintercept = quantile(boot_slope,0.975)),size=1) +
    coord_cartesian(xlim = c(0, 3)) +
    xlab("Estimated Slopes") +
    ggtitle("Sampling distribution and CI for the estimator of the slope, n=250")

slope_sampling_dist_250
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c34335dad7d12c94fb421cf138b81e74", "grade": false, "grade_id": "cell-3f04bc89860a06bb", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### With `infer`
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd972ec2e3d73c4ec019adfcc545f7b76', 'grade': False, 'grade_id': 'cell-ef37e444faa69059', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
#run this cell

visualize(bootstrap_slope_infer, bin=30) + 
  shade_confidence_interval(endpoints = percentile_ci, fill = "white",
                            linetype = "solid", color = "black") 
```

```{r}

```
